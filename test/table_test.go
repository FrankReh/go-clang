// Generated by go test -update.
// Edit by hand to add or modify test cases.  Use go test -update to get this
// file regenerated with the expected output of those test cases.
//
// Test cases that you comment out by hand will be lost if the -update flag is
// used.  Rather than comment out the test cases, set their Disable property to
// true if you may want to update the results. The Disable property is
// maintained.
//
// Similarly, any comments you make for yourself while testing will be lost if
// you update this file. But there is a string property named Comment that you
// can use that is retained during update.

package clang_test

import (
	"github.com/frankreh/go-clang-v5.0/clang"
)

var testTupleData = []testTuple{

	{
		Name:             "empty_a1",
		ExpectedGobSize0: 1558,
		ExpectedGobSize1: 1279,
	},
	{
		Name: "empty_a2",
		ExpectedTUPopulate: `
            Tokens:

            TokenMap:

            TokenNameMap:

            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {0 0} {0 0}}
            CursorNameMap:
            0: 1:sample.c`,
		ExpectedGobSize0: 1558,
		ExpectedGobSize1: 1279,
	},
	{
		Name: "void_foo",
		SrcCode: `
			void foo() { }
			`,
		ExpectedTokens: `
            void : Keyword
             foo : Identifier
               ( : Punctuation
               ) : Punctuation
               { : Punctuation
               } : Punctuation`,
		ExpectedTopCursors: `foo FunctionDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            foo/FunctionDecl {first-seen:1 FunctionNoProto 'void ()' !POD numargs:0 result:{first-seen:2 Void 'void' !POD} align:4 size:1 Variadic}
            . CompoundStmt:IsStatement `,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Punctuation 4} 5:{Punctuation 5}
            TokenNameMap:
            0:void 1:foo 2:( 3:) 4:{ 5:}
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Void 0} {FunctionNoProto 0}]
                Intrinsics: [{{Void} void 0 0}]
                Functions: [{{FunctionNoProto} 2 [] void ()}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 1} {0 6}} 1:{FunctionDecl 2 0 3 {2 1} {0 6}} 2:{CompoundStmt 0 1 0 {0 0} {4 2}}
            CursorNameMap:
            0: 1:sample.c 2:foo`,
		ExpectedGobSize0: 1689,
		ExpectedGobSize1: 1383,
	},
	{
		Name: "charp_foo_if",
		SrcCode: `
			char* foo(int i) { if (i >= 0) return "yes"; else return "no"; }
			`,
		ExpectedTokens: `
              char : Keyword
                 * : Punctuation
               foo : Identifier
                 ( : Punctuation
               int : Keyword
                 i : Identifier
                 ) : Punctuation
                 { : Punctuation
                if : Keyword
                 ( : Punctuation
                 i : Identifier
                >= : Punctuation
                 0 : Literal
                 ) : Punctuation
            return : Keyword
             "yes" : Literal
                 ; : Punctuation
              else : Keyword
            return : Keyword
              "no" : Literal
                 ; : Punctuation
                 } : Punctuation`,
		ExpectedTopCursors: `foo FunctionDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            foo/FunctionDecl {first-seen:1 FunctionProto 'char *(int)' !POD numargs:1 result:{first-seen:2 Pointer 'char *' *{first-seen:3 Char_S 'char' align:1 size:1} align:8 size:8} align:4 size:1}
            . i/ParmDecl {first-seen:4 Int 'int' align:4 size:4}
            . CompoundStmt:IsStatement 
            . . IfStmt:IsStatement 
            . . . BinaryOperator:IsExpression:[i : Identifier, >= : Punctuation, 0 : Literal]/ {seen-before:4}
            . . . . IsUnexposed(UnexposedExpr) {seen-before:4}
            . . . . . DeclRefExpr:IsExpression:[i : Identifier]/i {seen-before:4}
            . . . . 0/IntegerLiteral:IsLiteral/ {seen-before:4}
            . . . ReturnStmt:IsStatement 
            . . . . IsUnexposed(UnexposedExpr) {seen-before:2}
            . . . . . "yes"/StringLiteral:IsLiteral/"yes" {first-seen:5 ConstantArray 'char [4]' align:1 size:4 len:4 elem:{seen-before:3}}
            . . . ReturnStmt:IsStatement 
            . . . . IsUnexposed(UnexposedExpr) {seen-before:2}
            . . . . . "no"/StringLiteral:IsLiteral/"no" {first-seen:6 ConstantArray 'char [3]' align:1 size:3 len:3 elem:{seen-before:3}}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8 9:3 10:5 11:9 12:10 13:6 14:11 15:12 16:13 17:14 18:11 19:15 20:13 21:16
            TokenMap:
            0:{Keyword 0} 1:{Punctuation 1} 2:{Identifier 2} 3:{Punctuation 3} 4:{Keyword 4} 5:{Identifier 5} 6:{Punctuation 6}
            7:{Punctuation 7} 8:{Keyword 8} 9:{Punctuation 9} 10:{Literal 10} 11:{Keyword 11} 12:{Literal 12} 13:{Punctuation 13}
            14:{Keyword 14} 15:{Literal 15} 16:{Punctuation 16}
            TokenNameMap:
            0:char 1:* 2:foo 3:( 4:int 5:i 6:) 7:{ 8:if 9:>= 10:0 11:return 12:"yes" 13:; 14:else 15:"no" 16:}
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0} {Char_S 1} {Pointer 3} {FunctionProto 0} {ConstantArray 0} {ConstantArray 1}]
                Intrinsics: [{{Int} int 4 4} {{Char_S} char 1 1}]
                Functions: [{{FunctionProto} 4 [2] char *(int)}]
                Arrays: [{4 {3 1 4 char [4]}} {3 {3 1 3 char [3]}}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 1} {0 22}} 1:{FunctionDecl 2 0 5 {2 2} {0 22}} 2:{ParmDecl 3 1 2 {0 0} {4 2}}
            3:{CompoundStmt 0 1 0 {4 1} {7 15}} 4:{IfStmt 0 3 0 {5 3} {8 12}} 5:{BinaryOperator 6 4 2 {8 2} {10 3}}
            6:{ReturnStmt 0 4 0 {10 1} {14 2}} 7:{ReturnStmt 0 4 0 {11 1} {18 2}} 8:{UnexposedExpr 3 5 2 {12 1} {10 1}}
            9:{IntegerLiteral 0 5 2 {0 0} {12 1}} 10:{UnexposedExpr 0 6 4 {13 1} {15 1}} 11:{UnexposedExpr 0 7 4 {14 1} {19 1}}
            12:{DeclRefExpr 3 8 2 {0 0} {10 1}} 13:{StringLiteral 4 10 6 {0 0} {15 1}} 14:{StringLiteral 5 11 7 {0 0} {19 1}}
            CursorNameMap:
            0: 1:sample.c 2:foo 3:i 4:"yes" 5:"no" 6:>=`,
		ExpectedGobSize0: 2134,
		ExpectedGobSize1: 1682,
	},
	{
		Name: "int_foo_if_float",
		SrcCode: `
			int foo(float i) { if (i) return 1; else return 0; }
			`,
		ExpectedFullCursors: `
            foo/FunctionDecl {first-seen:1 FunctionProto 'int (float)' !POD numargs:1 result:{first-seen:2 Int 'int' align:4 size:4} align:4 size:1}
            . i/ParmDecl {first-seen:3 Float 'float' align:4 size:4}
            . CompoundStmt:IsStatement 
            . . IfStmt:IsStatement 
            . . . IsUnexposed(UnexposedExpr) {seen-before:3}
            . . . . DeclRefExpr:IsExpression:[i : Identifier]/i {seen-before:3}
            . . . ReturnStmt:IsStatement 
            . . . . 1/IntegerLiteral:IsLiteral/ {seen-before:2}
            . . . ReturnStmt:IsStatement 
            . . . . 0/IntegerLiteral:IsLiteral/ {seen-before:2}`,
		ExpectedGobSize0: 1952,
		ExpectedGobSize1: 1553,
	},
	{
		Name:    "int_world",
		SrcCode: `int world();`,
		ExpectedTokens: `
              int : Keyword
            world : Identifier
                ( : Punctuation
                ) : Punctuation
                ; : Punctuation`,
	},
	{
		Name:    "define_A_a_plus_1",
		SrcCode: `#define A(a) (a + 1)`,
		ExpectedTokens: `
                 # : Punctuation
            define : Identifier
                 A : Identifier
                 ( : Punctuation
                 a : Identifier
                 ) : Punctuation
                 ( : Punctuation
                 a : Identifier
                 + : Punctuation
                 1 : Literal
                 ) : Punctuation`,
	},
	{
		Name: "define_A_a_plus_1_called_by_foo",
		SrcCode: `
			#define Add(a) (a + 1)
			int foo(int b) {
				if (b & 0x1) {
					return Add(b);
				}
			}
			`,
		ExpectedTokens: `
                 # : Punctuation
            define : Identifier
               Add : Identifier
                 ( : Punctuation
                 a : Identifier
                 ) : Punctuation
                 ( : Punctuation
                 a : Identifier
                 + : Punctuation
                 1 : Literal
                 ) : Punctuation
               int : Keyword
               foo : Identifier
                 ( : Punctuation
               int : Keyword
                 b : Identifier
                 ) : Punctuation
                 { : Punctuation
                if : Keyword
                 ( : Punctuation
                 b : Identifier
                 & : Punctuation
               0x1 : Literal
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
               Add : Identifier
                 ( : Punctuation
                 b : Identifier
                 ) : Punctuation
                 ; : Punctuation
                 } : Punctuation
                 } : Punctuation`,
	},
	{
		Name: "static_var_and_func",
		SrcCode: `
			static int sa = 7;
			static int getsaI() {
				return sa
			}
			int getsa() {
				return getsaI()
			}
			`,
		ExpectedTokens: `
            static : Keyword
               int : Keyword
                sa : Identifier
                 = : Punctuation
                 7 : Literal
                 ; : Punctuation
            static : Keyword
               int : Keyword
            getsaI : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
                sa : Identifier
                 } : Punctuation
               int : Keyword
             getsa : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
            getsaI : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 } : Punctuation`,
	},
	{
		Name:    "global_var_int_a_is_1",
		SrcCode: `int a = 1;`,
		ExpectedTokens: `
            int : Keyword
              a : Identifier
              = : Punctuation
              1 : Literal
              ; : Punctuation`,
		ExpectedTopCursors: `a VarDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            a/VarDecl {first-seen:1 Int 'int' align:4 size:4}
            . 1/IntegerLiteral:IsLiteral/ {seen-before:1}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Literal 3} 4:{Punctuation 4}
            TokenNameMap:
            0:int 1:a 2:= 3:1 4:;
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 1} {0 5}} 1:{VarDecl 2 0 2 {2 1} {0 4}} 2:{IntegerLiteral 0 1 2 {0 0} {3 1}}
            CursorNameMap:
            0: 1:sample.c 2:a`,
		ExpectedGobSize0: 1661,
		ExpectedGobSize1: 1353,
	},
	{
		Name:    "global_var_unsigned_int_a_is_0x1",
		SrcCode: `unsigned int a = 0x1;`,
		ExpectedTokens: `
            unsigned : Keyword
                 int : Keyword
                   a : Identifier
                   = : Punctuation
                 0x1 : Literal
                   ; : Punctuation`,
		ExpectedTopCursors: `a VarDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            a/VarDecl {first-seen:1 UInt 'unsigned int' align:4 size:4}
            . IsUnexposed(UnexposedExpr) {seen-before:1}
            . . 0x1/IntegerLiteral:IsLiteral/ {first-seen:2 Int 'int' align:4 size:4}`,
		ExpectedGobSize0: 1726,
		ExpectedGobSize1: 1405,
	},
	{
		Name:    "global_var_a_is_0_001",
		SrcCode: `double a = 0.001;`,
		ExpectedTokens: `
            double : Keyword
                 a : Identifier
                 = : Punctuation
             0.001 : Literal
                 ; : Punctuation`,
		ExpectedTopCursors: `a VarDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            a/VarDecl {first-seen:1 Double 'double' align:8 size:8}
            . 0.001/FloatingLiteral:IsLiteral/ {seen-before:1}`,
		ExpectedGobSize0: 1671,
		ExpectedGobSize1: 1363,
	},
	{
		Name: "function_storage_comparison",
		SrcCode: `int A() { return 1; }
			  extern int B() {return 2; }
			  static int C() {return 3; }
			  inline int D() {return 4; }
			  `,
		ExpectedTopCursors: `
            A FunctionDecl IsDeclaration SC_None   Linkage_External
            B FunctionDecl IsDeclaration SC_Extern Linkage_External
            C FunctionDecl IsDeclaration SC_Static Linkage_Internal
            D FunctionDecl IsDeclaration SC_None   Linkage_External`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8 9:9 10:0 11:10 12:2 13:3 14:4 15:5 16:11 17:7 18:8 19:12 20:0 21:13 22:2 23:3 24:4
            25:5 26:14 27:7 28:8 29:15 30:0 31:16 32:2 33:3 34:4 35:5 36:17 37:7 38:8
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Punctuation 4} 5:{Keyword 5} 6:{Literal 6}
            7:{Punctuation 7} 8:{Punctuation 8} 9:{Keyword 9} 10:{Identifier 10} 11:{Literal 11} 12:{Keyword 12} 13:{Identifier 13}
            14:{Literal 14} 15:{Keyword 15} 16:{Identifier 16} 17:{Literal 17}
            TokenNameMap:
            0:int 1:A 2:( 3:) 4:{ 5:return 6:1 7:; 8:} 9:extern 10:B 11:2 12:static 13:C 14:3 15:inline 16:D 17:4
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0} {FunctionNoProto 0}]
                Intrinsics: [{{Int} int 4 4}]
                Functions: [{{FunctionNoProto} 2 [] int ()}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 4} {0 39}} 1:{FunctionDecl 2 0 3 {5 1} {0 9}} 2:{FunctionDecl 3 0 3 {6 1} {9 10}}
            3:{FunctionDecl 4 0 3 {7 1} {19 10}} 4:{FunctionDecl 5 0 3 {8 1} {29 10}} 5:{CompoundStmt 0 1 0 {9 1} {4 5}}
            6:{CompoundStmt 0 2 0 {10 1} {14 5}} 7:{CompoundStmt 0 3 0 {11 1} {24 5}} 8:{CompoundStmt 0 4 0 {12 1} {34 5}}
            9:{ReturnStmt 0 5 0 {13 1} {5 2}} 10:{ReturnStmt 0 6 0 {14 1} {15 2}} 11:{ReturnStmt 0 7 0 {15 1} {25 2}}
            12:{ReturnStmt 0 8 0 {16 1} {35 2}} 13:{IntegerLiteral 0 9 2 {0 0} {6 1}} 14:{IntegerLiteral 0 10 2 {0 0} {16 1}}
            15:{IntegerLiteral 0 11 2 {0 0} {26 1}} 16:{IntegerLiteral 0 12 2 {0 0} {36 1}}
            CursorNameMap:
            0: 1:sample.c 2:A 3:B 4:C 5:D`,
		ExpectedGobSize0: 2086,
		ExpectedGobSize1: 1623,
	},
	{
		Name:    "void_function_and_return",
		SrcCode: `void A() { return; }`,
		ExpectedTokens: `
              void : Keyword
                 A : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
                 ; : Punctuation
                 } : Punctuation`,
		ExpectedTopCursors: `A FunctionDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            A/FunctionDecl {first-seen:1 FunctionNoProto 'void ()' !POD numargs:0 result:{first-seen:2 Void 'void' !POD} align:4 size:1 Variadic}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement `,
		ExpectedGobSize0: 1723,
		ExpectedGobSize1: 1406,
	},
	{
		Name:    "int_function_and_return_1",
		SrcCode: `int A() { return 1; }`,
		ExpectedFullCursors: `
            A/FunctionDecl {first-seen:1 FunctionNoProto 'int ()' !POD numargs:0 result:{first-seen:2 Int 'int' align:4 size:4} align:4 size:1 Variadic}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . 1/IntegerLiteral:IsLiteral/ {seen-before:2}`,
		ExpectedGobSize0: 1752,
		ExpectedGobSize1: 1422,
	},
	{
		Name: "parenthesis_comparison",
		SrcCode: `int A() { return 1; }
					  int B() { return (2); }
					  int C() { return ((2)); }
					  `,
		ExpectedFullCursors: `
            A/FunctionDecl {first-seen:1 FunctionNoProto 'int ()' !POD numargs:0 result:{first-seen:2 Int 'int' align:4 size:4} align:4 size:1 Variadic}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . 1/IntegerLiteral:IsLiteral/ {seen-before:2}
            B/FunctionDecl {seen-before:1}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . ParenExpr:IsExpression:[( : Punctuation, 2 : Literal, ) : Punctuation]/ {seen-before:2}
            . . . . 2/IntegerLiteral:IsLiteral/ {seen-before:2}
            C/FunctionDecl {seen-before:1}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . ParenExpr:IsExpression:[( : Punctuation, ( : Punctuation, 2 : Literal, ) : Punctuation, ) : Punctuation]/ {seen-before:2}
            . . . . ParenExpr:IsExpression:[( : Punctuation, 2 : Literal, ) : Punctuation]/ {seen-before:2}
            . . . . . 2/IntegerLiteral:IsLiteral/ {seen-before:2}`,
		ExpectedGobSize0: 2008,
		ExpectedGobSize1: 1550,
	},
	{
		Name: "func_sub_77_and_78",
		SrcCode: `int A() { return 77 - 78; }
					  `,
		ExpectedTokens: `
               int : Keyword
                 A : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
                77 : Literal
                 - : Punctuation
                78 : Literal
                 ; : Punctuation
                 } : Punctuation`,
		ExpectedFullCursors: `
            A/FunctionDecl {first-seen:1 FunctionNoProto 'int ()' !POD numargs:0 result:{first-seen:2 Int 'int' align:4 size:4} align:4 size:1 Variadic}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . BinaryOperator:IsExpression:[77 : Literal, - : Punctuation, 78 : Literal]/ {seen-before:2}
            . . . . 77/IntegerLiteral:IsLiteral/ {seen-before:2}
            . . . . 78/IntegerLiteral:IsLiteral/ {seen-before:2}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8 9:9 10:10
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Punctuation 4} 5:{Keyword 5} 6:{Literal 6}
            7:{Punctuation 7} 8:{Literal 8} 9:{Punctuation 9} 10:{Punctuation 10}
            TokenNameMap:
            0:int 1:A 2:( 3:) 4:{ 5:return 6:77 7:- 8:78 9:; 10:}
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0} {FunctionNoProto 0}]
                Intrinsics: [{{Int} int 4 4}]
                Functions: [{{FunctionNoProto} 2 [] int ()}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 1} {0 11}} 1:{FunctionDecl 2 0 3 {2 1} {0 11}} 2:{CompoundStmt 0 1 0 {3 1} {4 7}}
            3:{ReturnStmt 0 2 0 {4 1} {5 4}} 4:{BinaryOperator 3 3 2 {5 2} {6 3}} 5:{IntegerLiteral 0 4 2 {0 0} {6 1}}
            6:{IntegerLiteral 0 4 2 {0 0} {8 1}}
            CursorNameMap:
            0: 1:sample.c 2:A 3:-`,
		ExpectedGobSize0: 1809,
		ExpectedGobSize1: 1454,
	},
	{
		Name:    "var_sub_77_and_78",
		SrcCode: `int a = 77 - 78;`,
		ExpectedTokens: `
            int : Keyword
              a : Identifier
              = : Punctuation
             77 : Literal
              - : Punctuation
             78 : Literal
              ; : Punctuation`,
		ExpectedFullCursors: `
            a/VarDecl {first-seen:1 Int 'int' align:4 size:4}
            . BinaryOperator:IsExpression:[77 : Literal, - : Punctuation, 78 : Literal]/ {seen-before:1}
            . . 77/IntegerLiteral:IsLiteral/ {seen-before:1}
            . . 78/IntegerLiteral:IsLiteral/ {seen-before:1}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Literal 3} 4:{Punctuation 4} 5:{Literal 5} 6:{Punctuation 6}
            TokenNameMap:
            0:int 1:a 2:= 3:77 4:- 5:78 6:;
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 1} {0 7}} 1:{VarDecl 2 0 2 {2 1} {0 6}} 2:{BinaryOperator 3 1 2 {3 2} {3 3}}
            3:{IntegerLiteral 0 2 2 {0 0} {3 1}} 4:{IntegerLiteral 0 2 2 {0 0} {5 1}}
            CursorNameMap:
            0: 1:sample.c 2:a 3:-`,
		ExpectedGobSize0: 1717,
		ExpectedGobSize1: 1385,
	},
	{
		Name:    "var_sub_p77p_and_78",
		Comment: `BinaryOperator - has 5 tokens and 2 children. First child has 3 tokens. Means the 4th is the binary operator symbol.`,
		SrcCode: `int a = (77) - 78;`,
		ExpectedTokens: `
            int : Keyword
              a : Identifier
              = : Punctuation
              ( : Punctuation
             77 : Literal
              ) : Punctuation
              - : Punctuation
             78 : Literal
              ; : Punctuation`,
		ExpectedFullCursors: `
            a/VarDecl {first-seen:1 Int 'int' align:4 size:4}
            . BinaryOperator:IsExpression:[( : Punctuation, 77 : Literal, ) : Punctuation, - : Punctuation, 78 : Literal]/ {seen-before:1}
            . . ParenExpr:IsExpression:[( : Punctuation, 77 : Literal, ) : Punctuation]/ {seen-before:1}
            . . . 77/IntegerLiteral:IsLiteral/ {seen-before:1}
            . . 78/IntegerLiteral:IsLiteral/ {seen-before:1}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Literal 4} 5:{Punctuation 5} 6:{Punctuation 6}
            7:{Literal 7} 8:{Punctuation 8}
            TokenNameMap:
            0:int 1:a 2:= 3:( 4:77 5:) 6:- 7:78 8:;
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 1} {0 9}} 1:{VarDecl 2 0 2 {2 1} {0 8}} 2:{BinaryOperator 3 1 2 {3 2} {3 5}}
            3:{ParenExpr 0 2 2 {5 1} {3 3}} 4:{IntegerLiteral 0 2 2 {0 0} {7 1}} 5:{IntegerLiteral 0 3 2 {0 0} {4 1}}
            CursorNameMap:
            0: 1:sample.c 2:a 3:-`,
		ExpectedGobSize0: 1749,
		ExpectedGobSize1: 1404,
	},
	{
		Name:    "var_a_is_minus_b",
		Comment: ` UnaryOperator - has 2 tokens and 1 children. First child has 1 token. Means the 1st is the unary operator symbol.`,
		SrcCode: `int a = 99;
					  int b = -a;`,
		ExpectedTokens: `
            int : Keyword
              a : Identifier
              = : Punctuation
             99 : Literal
              ; : Punctuation
            int : Keyword
              b : Identifier
              = : Punctuation
              - : Punctuation
              a : Identifier
              ; : Punctuation`,
		ExpectedFullCursors: `
            a/VarDecl {first-seen:1 Int 'int' align:4 size:4}
            . 99/IntegerLiteral:IsLiteral/ {seen-before:1}
            b/VarDecl {seen-before:1}
            . UnaryOperator:IsExpression:[- : Punctuation, a : Identifier]/ {seen-before:1}
            . . IsUnexposed(UnexposedExpr) {seen-before:1}
            . . . DeclRefExpr:IsExpression:[a : Identifier]/a {seen-before:1}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:0 6:5 7:2 8:6 9:1 10:4
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Literal 3} 4:{Punctuation 4} 5:{Identifier 5} 6:{Punctuation 6}
            TokenNameMap:
            0:int 1:a 2:= 3:99 4:; 5:b 6:-
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 2} {0 11}} 1:{VarDecl 2 0 2 {3 1} {0 4}} 2:{VarDecl 3 0 2 {4 1} {5 5}}
            3:{IntegerLiteral 0 1 2 {0 0} {3 1}} 4:{UnaryOperator 0 2 2 {5 1} {8 2}} 5:{UnexposedExpr 2 4 2 {6 1} {9 1}}
            6:{DeclRefExpr 2 5 2 {0 0} {9 1}}
            CursorNameMap:
            0: 1:sample.c 2:a 3:b`,
		ExpectedGobSize0: 1761,
		ExpectedGobSize1: 1401,
	},
	{
		Name: "add_sub_mul_div",
		SrcCode: `int A() { return 1 + 2 - 3 * 4 / 5; }
					  `,
		ExpectedTokens: `
               int : Keyword
                 A : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
                 1 : Literal
                 + : Punctuation
                 2 : Literal
                 - : Punctuation
                 3 : Literal
                 * : Punctuation
                 4 : Literal
                 / : Punctuation
                 5 : Literal
                 ; : Punctuation
                 } : Punctuation`,
		ExpectedFullCursors: `
            A/FunctionDecl {first-seen:1 FunctionNoProto 'int ()' !POD numargs:0 result:{first-seen:2 Int 'int' align:4 size:4} align:4 size:1 Variadic}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . BinaryOperator:IsExpression:[1 : Literal, + : Punctuation, 2 : Literal, - : Punctuation, 3 : Literal, * : Punctuation, 4 : Literal, / : Punctuation, 5 : Literal]/ {seen-before:2}
            . . . . BinaryOperator:IsExpression:[1 : Literal, + : Punctuation, 2 : Literal]/ {seen-before:2}
            . . . . . 1/IntegerLiteral:IsLiteral/ {seen-before:2}
            . . . . . 2/IntegerLiteral:IsLiteral/ {seen-before:2}
            . . . . BinaryOperator:IsExpression:[3 : Literal, * : Punctuation, 4 : Literal, / : Punctuation, 5 : Literal]/ {seen-before:2}
            . . . . . BinaryOperator:IsExpression:[3 : Literal, * : Punctuation, 4 : Literal]/ {seen-before:2}
            . . . . . . 3/IntegerLiteral:IsLiteral/ {seen-before:2}
            . . . . . . 4/IntegerLiteral:IsLiteral/ {seen-before:2}
            . . . . . 5/IntegerLiteral:IsLiteral/ {seen-before:2}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8 9:9 10:10 11:11 12:12 13:13 14:14 15:15 16:16
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Punctuation 4} 5:{Keyword 5} 6:{Literal 6}
            7:{Punctuation 7} 8:{Literal 8} 9:{Punctuation 9} 10:{Literal 10} 11:{Punctuation 11} 12:{Literal 12}
            13:{Punctuation 13} 14:{Literal 14} 15:{Punctuation 15} 16:{Punctuation 16}
            TokenNameMap:
            0:int 1:A 2:( 3:) 4:{ 5:return 6:1 7:+ 8:2 9:- 10:3 11:* 12:4 13:/ 14:5 15:; 16:}
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0} {FunctionNoProto 0}]
                Intrinsics: [{{Int} int 4 4}]
                Functions: [{{FunctionNoProto} 2 [] int ()}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 1} {0 17}} 1:{FunctionDecl 2 0 3 {2 1} {0 17}} 2:{CompoundStmt 0 1 0 {3 1} {4 13}}
            3:{ReturnStmt 0 2 0 {4 1} {5 10}} 4:{BinaryOperator 3 3 2 {5 2} {6 9}} 5:{BinaryOperator 4 4 2 {7 2} {6 3}}
            6:{BinaryOperator 5 4 2 {9 2} {10 5}} 7:{IntegerLiteral 0 5 2 {0 0} {6 1}} 8:{IntegerLiteral 0 5 2 {0 0} {8 1}}
            9:{BinaryOperator 6 6 2 {11 2} {10 3}} 10:{IntegerLiteral 0 6 2 {0 0} {14 1}} 11:{IntegerLiteral 0 9 2 {0 0} {10 1}}
            12:{IntegerLiteral 0 9 2 {0 0} {12 1}}
            CursorNameMap:
            0: 1:sample.c 2:A 3:- 4:+ 5:/ 6:*`,
		ExpectedGobSize0: 1969,
		ExpectedGobSize1: 1542,
	},
	{
		Name: "add_and_double_add",
		SrcCode: `int A() { return 1 + 2; }
					  int B() { return 1 + 2 + 3; }
					  `,
		ExpectedFullCursors: `
            A/FunctionDecl {first-seen:1 FunctionNoProto 'int ()' !POD numargs:0 result:{first-seen:2 Int 'int' align:4 size:4} align:4 size:1 Variadic}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . BinaryOperator:IsExpression:[1 : Literal, + : Punctuation, 2 : Literal]/ {seen-before:2}
            . . . . 1/IntegerLiteral:IsLiteral/ {seen-before:2}
            . . . . 2/IntegerLiteral:IsLiteral/ {seen-before:2}
            B/FunctionDecl {seen-before:1}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . BinaryOperator:IsExpression:[1 : Literal, + : Punctuation, 2 : Literal, + : Punctuation, 3 : Literal]/ {seen-before:2}
            . . . . BinaryOperator:IsExpression:[1 : Literal, + : Punctuation, 2 : Literal]/ {seen-before:2}
            . . . . . 1/IntegerLiteral:IsLiteral/ {seen-before:2}
            . . . . . 2/IntegerLiteral:IsLiteral/ {seen-before:2}
            . . . . 3/IntegerLiteral:IsLiteral/ {seen-before:2}`,
		ExpectedGobSize0: 1985,
		ExpectedGobSize1: 1538,
	},
	{
		Name:    "hdr_processing_only",
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		HdrCode: `
			  extern int hdr_ext_v;
			  static int hdr_sta_v;
			  static int hdr_sta_v = 2;
			  int hdr_glo_v = 3;

			  extern int hdr_ext_f();
			  inline int hdr_inl_f()       { return 11; }
			  static int hdr_sta_f()       { return 12; }
			  int hdr_glo_f()	           { return 13; }
			  static inline int hdr_si_f() { return 14; }
			  `,
		ExpectedGobSize0: 1621,
		ExpectedGobSize1: 1329,
	},
	{
		Name:    "hdr_and_source",
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		HdrCode: `#define MSG "Hello World!"
			  extern int printf(const char* fmt);
			  `,
		SrcCode: `int A() { return 1; }
			  extern int B() {return 2; }
			  static int C() {return 3; }
			  inline int D() {return 4; }
			  `,
		ExpectedTopCursors: `
            A FunctionDecl IsDeclaration SC_None   Linkage_External
            B FunctionDecl IsDeclaration SC_Extern Linkage_External
            C FunctionDecl IsDeclaration SC_Static Linkage_Internal
            D FunctionDecl IsDeclaration SC_None   Linkage_External`,
		ExpectedFullCursors: `
            A/FunctionDecl {first-seen:1 FunctionNoProto 'int ()' !POD numargs:0 result:{first-seen:2 Int 'int' align:4 size:4} align:4 size:1 Variadic}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . 1/IntegerLiteral:IsLiteral/ {seen-before:2}
            B/FunctionDecl {seen-before:1}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . 2/IntegerLiteral:IsLiteral/ {seen-before:2}
            C/FunctionDecl {seen-before:1}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . 3/IntegerLiteral:IsLiteral/ {seen-before:2}
            D/FunctionDecl {seen-before:1}
            . CompoundStmt:IsStatement 
            . . ReturnStmt:IsStatement 
            . . . 4/IntegerLiteral:IsLiteral/ {seen-before:2}`,
		ExpectedGobSize0: 2141,
		ExpectedGobSize1: 1671,
	},
	{
		Name:    "struct_a_b",
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
				  struct StructS {
					  int a;
					  char b;
				  } VarS;
				  `,
		ExpectedTokens: `
             struct : Keyword
            StructS : Identifier
                  { : Punctuation
                int : Keyword
                  a : Identifier
                  ; : Punctuation
               char : Keyword
                  b : Identifier
                  ; : Punctuation
                  } : Punctuation
               VarS : Identifier
                  ; : Punctuation`,
		ExpectedTopCursors: `
            StructS StructDecl IsDeclaration         Linkage_External
            VarS    VarDecl    IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            StructS/StructDecl {first-seen:1 Record 'struct StructS' align:4 size:8}
            . a/FieldDecl {first-seen:2 Int 'int' align:4 size:4}
            . b/FieldDecl {first-seen:3 Char_S 'char' align:1 size:1}
            VarS/VarDecl {first-seen:4 Elaborated 'struct StructS' Canon:{seen-before:1} align:4 size:8}
            . [0 backreference]`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:5 9:8 10:9 11:5
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Keyword 3} 4:{Identifier 4} 5:{Punctuation 5} 6:{Keyword 6}
            7:{Identifier 7} 8:{Punctuation 8} 9:{Identifier 9}
            TokenNameMap:
            0:struct 1:StructS 2:{ 3:int 4:a 5:; 6:char 7:b 8:} 9:VarS
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Record 0} {Elaborated 2} {Int 0} {Char_S 1}]
                Intrinsics: [{{Int} int 4 4} {{Char_S} char 1 1}]
                Records: [{4 8 struct StructS}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 2} {0 12}} 1:{StructDecl 2 0 2 {3 2} {0 10}} 2:{VarDecl 3 0 3 {5 1} {0 11}}
            3:{FieldDecl 4 1 4 {0 0} {3 2}} 4:{FieldDecl 5 1 5 {0 0} {6 2}} 5:{Back 0 2 0 {0 0} {0 0}}
            CursorNameMap:
            0: 1:sample.c 2:StructS 3:VarS 4:a 5:b
            Back:
            5:1`,
		ExpectedGobSize0: 1833,
		ExpectedGobSize1: 1497,
	},
	{
		Name:    "typedef_int_II",
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
				  typedef int II;
				  II ii;
				  `,
		ExpectedTokens: `
            typedef : Keyword
                int : Keyword
                 II : Identifier
                  ; : Punctuation
                 II : Identifier
                 ii : Identifier
                  ; : Punctuation`,
		ExpectedTopCursors: `
            II TypedefDecl IsDeclaration         Linkage_NoLinkage
            ii VarDecl     IsDeclaration SC_None Linkage_External `,
		ExpectedFullCursors: `
            II/TypedefDecl {first-seen:1 Typedef 'II' Canon:{first-seen:2 Int 'int' align:4 size:4} align:4 size:4}
            ii/VarDecl {seen-before:1}
            . II/TypeRef {seen-before:1}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:2 5:4 6:3
            TokenMap:
            0:{Keyword 0} 1:{Keyword 1} 2:{Identifier 2} 3:{Punctuation 3} 4:{Identifier 4}
            TokenNameMap:
            0:typedef 1:int 2:II 3:; 4:ii
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0} {Typedef 0}]
                Intrinsics: [{{Int} int 4 4}]
                Typedefs: [{2 II}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 2} {0 7}} 1:{TypedefDecl 2 0 3 {0 0} {0 3}} 2:{VarDecl 3 0 3 {3 1} {4 2}}
            3:{TypeRef 2 2 3 {0 0} {4 1}}
            CursorNameMap:
            0: 1:sample.c 2:II 3:ii`,
		ExpectedGobSize0: 1706,
		ExpectedGobSize1: 1387,
	},
	{
		Name: "typedef_struct_TA",
		Comment: `The 4th cursor encountered is the same as the first.
			This is interesting because while the typedef appears first in the
			source, libclang has the cursor for the struct itself visited first
			at the top level.`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            typedef struct { int a; } TA;
            TA ss;
        `,
		ExpectedTopCursors: `
               StructDecl  IsDeclaration         Linkage_External
            TA TypedefDecl IsDeclaration         Linkage_External
            ss VarDecl     IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            /StructDecl {first-seen:1 Record 'TA' align:4 size:4}
            . a/FieldDecl {first-seen:2 Int 'int' align:4 size:4}
            TA/TypedefDecl {first-seen:3 Typedef 'TA' Canon:{seen-before:1} align:4 size:4}
            . [0 backreference]
            ss/VarDecl {seen-before:3}
            . TA/TypeRef {seen-before:3}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:5 9:7 10:8 11:5
            TokenMap:
            0:{Keyword 0} 1:{Keyword 1} 2:{Punctuation 2} 3:{Keyword 3} 4:{Identifier 4} 5:{Punctuation 5} 6:{Punctuation 6}
            7:{Identifier 7} 8:{Identifier 8}
            TokenNameMap:
            0:typedef 1:struct 2:{ 3:int 4:a 5:; 6:} 7:TA 8:ss
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Record 0} {Typedef 0} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
                Records: [{4 4 TA}]
                Typedefs: [{2 TA}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 3} {0 12}} 1:{StructDecl 0 0 2 {4 1} {1 6}} 2:{TypedefDecl 2 0 3 {5 1} {0 8}}
            3:{VarDecl 3 0 3 {6 1} {9 2}} 4:{FieldDecl 4 1 4 {0 0} {3 2}} 5:{Back 0 2 0 {0 0} {0 0}} 6:{TypeRef 2 3 3 {0 0} {9 1}}
            CursorNameMap:
            0: 1:sample.c 2:TA 3:ss 4:a
            Back:
            5:1`,
		ExpectedGobSize0: 1807,
		ExpectedGobSize1: 1458,
	},
	{
		Name: "typedefs_two_structs",
		Comment: `
			For each typedef, the unnamed struct appears first in ast, without a name.
			Each TypedefDecl has a Back cursor.
			The variables themselves do not use back references the first time.
			x0 and x1 both have unique cursors although their types are for all intents
			and purposes identical.
			The y0 and y1 sahre the same cursor, they are declared in a single statement,
			even though they are on separate lines.
			`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            typedef struct { int a; } TA;
            typedef struct { int b; } TB;
            TA x0;
            TA x1;
            TB y0,
			   y1;
        `,
		ExpectedTopCursors: `
               StructDecl  IsDeclaration         Linkage_External
            TA TypedefDecl IsDeclaration         Linkage_External
               StructDecl  IsDeclaration         Linkage_External
            TB TypedefDecl IsDeclaration         Linkage_External
            x0 VarDecl     IsDeclaration SC_None Linkage_External
            x1 VarDecl     IsDeclaration SC_None Linkage_External
            y0 VarDecl     IsDeclaration SC_None Linkage_External
            y1 VarDecl     IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            /StructDecl {first-seen:1 Record 'TA' align:4 size:4}
            . a/FieldDecl {first-seen:2 Int 'int' align:4 size:4}
            TA/TypedefDecl {first-seen:3 Typedef 'TA' Canon:{seen-before:1} align:4 size:4}
            . [0 backreference]
            /StructDecl {first-seen:4 Record 'TB' align:4 size:4}
            . b/FieldDecl {seen-before:2}
            TB/TypedefDecl {first-seen:5 Typedef 'TB' Canon:{seen-before:4} align:4 size:4}
            . [4 backreference]
            x0/VarDecl {seen-before:3}
            . TA/TypeRef {seen-before:3}
            x1/VarDecl {seen-before:3}
            . TA/TypeRef {seen-before:3}
            y0/VarDecl {seen-before:5}
            . TB/TypeRef {seen-before:5}
            y1/VarDecl {seen-before:5}
            . [13 backreference]`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:5 9:0 10:1 11:2 12:3 13:8 14:5 15:6 16:9 17:5 18:7 19:10 20:5 21:7 22:11 23:5 24:9
            25:12 26:13 27:14 28:5
            TokenMap:
            0:{Keyword 0} 1:{Keyword 1} 2:{Punctuation 2} 3:{Keyword 3} 4:{Identifier 4} 5:{Punctuation 5} 6:{Punctuation 6}
            7:{Identifier 7} 8:{Identifier 8} 9:{Identifier 9} 10:{Identifier 10} 11:{Identifier 11} 12:{Identifier 12}
            13:{Punctuation 13} 14:{Identifier 14}
            TokenNameMap:
            0:typedef 1:struct 2:{ 3:int 4:a 5:; 6:} 7:TA 8:b 9:TB 10:x0 11:x1 12:y0 13:, 14:y1
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Record 0} {Typedef 0} {Record 1} {Typedef 1} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
                Records: [{4 4 TA} {4 4 TB}]
                Typedefs: [{2 TA} {4 TB}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 8} {0 29}} 1:{StructDecl 0 0 2 {9 1} {1 6}} 2:{TypedefDecl 2 0 3 {10 1} {0 8}}
            3:{StructDecl 0 0 4 {11 1} {10 6}} 4:{TypedefDecl 3 0 5 {12 1} {9 8}} 5:{VarDecl 4 0 3 {13 1} {18 2}}
            6:{VarDecl 5 0 3 {14 1} {21 2}} 7:{VarDecl 6 0 5 {15 1} {24 2}} 8:{VarDecl 7 0 5 {16 1} {24 4}}
            9:{FieldDecl 8 1 6 {0 0} {3 2}} 10:{Back 0 2 0 {0 0} {0 0}} 11:{FieldDecl 9 3 6 {0 0} {12 2}}
            12:{Back 0 4 0 {0 0} {0 0}} 13:{TypeRef 2 5 3 {0 0} {18 1}} 14:{TypeRef 2 6 3 {0 0} {21 1}}
            15:{TypeRef 3 7 5 {0 0} {24 1}} 16:{Back 0 8 0 {0 0} {0 0}}
            CursorNameMap:
            0: 1:sample.c 2:TA 3:TB 4:x0 5:x1 6:y0 7:y1 8:a 9:b
            Back:
            10:1 12:3 16:15`,
		ExpectedGobSize0: 2076,
		ExpectedGobSize1: 1625,
	},
	{
		Name: "compare_named_struct_with_typedef",
		Comment: `A struct on its own needs a name. The cursor for it provides that name.
            // The tree from below reorganized.
            0:{TranslationUnit  1 -1 {1 7}  {0 28}}
			  1:   {StructDecl  2  0 {8 1}  {0 7}}
			    8: {FieldDecl   8  1 {0 0}  {3 2}}
			  2:   {StructDecl  0  0 {9 1}  {9 6}}
				9: {FieldDecl   9  2 {0 0}  {11 2}}
              3:   {TypedefDecl 3  0 {10 1} {8 8}}
                10:{Back        0  3 {0 0}  {0 0}} 
			  4:   {VarDecl     4  0 {11 1} {17 3}}
			    11:{TypeRef    10  4 {0 0}  {18 1}} 
			  5:   {VarDecl     5  0 {12 1} {17 5}}
			    12:{Back        0  5 {0 0}  {0 0}} 
              6:   {VarDecl     6  0 {13 1} {23 2}}
			    13:{TypeRef     3  6 {0 0}  {23 1}}
			  7:   {VarDecl     7  0 {14 1} {23 4}}
                14:{Back        0  7 {0 0}  {0 0}}
			`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            struct SA { int a; };
            typedef struct { int b; } TB;
            struct SA x0, x1;
            TB y0, y1;
        `,
		ExpectedFullCursors: `
            SA/StructDecl {first-seen:1 Record 'struct SA' align:4 size:4}
            . a/FieldDecl {first-seen:2 Int 'int' align:4 size:4}
            /StructDecl {first-seen:3 Record 'TB' align:4 size:4}
            . b/FieldDecl {seen-before:2}
            TB/TypedefDecl {first-seen:4 Typedef 'TB' Canon:{seen-before:3} align:4 size:4}
            . [2 backreference]
            x0/VarDecl {first-seen:5 Elaborated 'struct SA' Canon:{seen-before:1} align:4 size:4}
            . struct SA/TypeRef {seen-before:1}
            x1/VarDecl {seen-before:5}
            . [7 backreference]
            y0/VarDecl {seen-before:4}
            . TB/TypeRef {seen-before:4}
            y1/VarDecl {seen-before:4}
            . [11 backreference]`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:5 8:7 9:0 10:2 11:3 12:8 13:5 14:6 15:9 16:5 17:0 18:1 19:10 20:11 21:12 22:5 23:9 24:13
            25:11 26:14 27:5
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Keyword 3} 4:{Identifier 4} 5:{Punctuation 5} 6:{Punctuation 6}
            7:{Keyword 7} 8:{Identifier 8} 9:{Identifier 9} 10:{Identifier 10} 11:{Punctuation 11} 12:{Identifier 12}
            13:{Identifier 13} 14:{Identifier 14}
            TokenNameMap:
            0:struct 1:SA 2:{ 3:int 4:a 5:; 6:} 7:typedef 8:b 9:TB 10:x0 11:, 12:x1 13:y0 14:y1
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Record 0} {Record 1} {Typedef 0} {Elaborated 2} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
                Records: [{4 4 struct SA} {4 4 TB}]
                Typedefs: [{3 TB}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 7} {0 28}} 1:{StructDecl 2 0 2 {8 1} {0 7}} 2:{StructDecl 0 0 3 {9 1} {9 6}}
            3:{TypedefDecl 3 0 4 {10 1} {8 8}} 4:{VarDecl 4 0 5 {11 1} {17 3}} 5:{VarDecl 5 0 5 {12 1} {17 5}}
            6:{VarDecl 6 0 4 {13 1} {23 2}} 7:{VarDecl 7 0 4 {14 1} {23 4}} 8:{FieldDecl 8 1 6 {0 0} {3 2}}
            9:{FieldDecl 9 2 6 {0 0} {11 2}} 10:{Back 0 3 0 {0 0} {0 0}} 11:{TypeRef 10 4 2 {0 0} {18 1}}
            12:{Back 0 5 0 {0 0} {0 0}} 13:{TypeRef 3 6 4 {0 0} {23 1}} 14:{Back 0 7 0 {0 0} {0 0}}
            CursorNameMap:
            0: 1:sample.c 2:SA 3:TB 4:x0 5:x1 6:y0 7:y1 8:a 9:b 10:struct SA
            Back:
            10:2 12:11 14:13`,
		ExpectedGobSize0: 2051,
		ExpectedGobSize1: 1622,
	},
	{
		Name: "compare_named_struct_with_two_typedefs",
		Comment: `
			// Two typedefs are declared. The first for a named struct.
			// libclang creates a sub ast for the unamed struct just as it
			// does for the named one. The only difference I can see is
			// the unnamed struct returns an empty string for Spelling().`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            struct SA { int a; };			// A named struct.
            typedef struct SA TA;			// A typedef using that named struct.
            typedef struct { int b; } TB;	// A new typedef for an unnamed struct.
            struct SA x0, x1;				// Two variables for same struct, will share cursor.
            TA y0, y1;
            TB z0, z1;
        `,
		ExpectedFullCursors: `
            SA/StructDecl {first-seen:1 Record 'struct SA' align:4 size:4}
            . a/FieldDecl {first-seen:2 Int 'int' align:4 size:4}
            TA/TypedefDecl {first-seen:3 Typedef 'TA' Canon:{seen-before:1} align:4 size:4}
            . struct SA/TypeRef {seen-before:1}
            /StructDecl {first-seen:4 Record 'TB' align:4 size:4}
            . b/FieldDecl {seen-before:2}
            TB/TypedefDecl {first-seen:5 Typedef 'TB' Canon:{seen-before:4} align:4 size:4}
            . [4 backreference]
            x0/VarDecl {first-seen:6 Elaborated 'struct SA' Canon:{seen-before:1} align:4 size:4}
            . struct SA/TypeRef {seen-before:1}
            x1/VarDecl {seen-before:6}
            . [9 backreference]
            y0/VarDecl {seen-before:3}
            . TA/TypeRef {seen-before:3}
            y1/VarDecl {seen-before:3}
            . [13 backreference]
            z0/VarDecl {seen-before:5}
            . TB/TypeRef {seen-before:5}
            z1/VarDecl {seen-before:5}
            . [17 backreference]`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:5 8:7 9:8 10:0 11:1 12:9 13:5 14:10 15:8 16:0 17:2 18:3 19:11 20:5 21:6 22:12 23:5 24:13
            25:0 26:1 27:14 28:15 29:16 30:5 31:17 32:9 33:18 34:15 35:19 36:5 37:12 38:20 39:15 40:21 41:5
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Keyword 3} 4:{Identifier 4} 5:{Punctuation 5} 6:{Punctuation 6}
            7:{Comment 7} 8:{Keyword 8} 9:{Identifier 9} 10:{Comment 10} 11:{Identifier 11} 12:{Identifier 12} 13:{Comment 13}
            14:{Identifier 14} 15:{Punctuation 15} 16:{Identifier 16} 17:{Comment 17} 18:{Identifier 18} 19:{Identifier 19}
            20:{Identifier 20} 21:{Identifier 21}
            TokenNameMap:
            0:struct 1:SA 2:{ 3:int 4:a 5:; 6:} 7:// A named struct. 8:typedef 9:TA 10:// A typedef using that named struct. 11:b
            12:TB 13:// A new typedef for an unnamed struct. 14:x0 15:, 16:x1
            17:// Two variables for same struct, will share cursor. 18:y0 19:y1 20:z0 21:z1
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Record 0} {Typedef 0} {Record 1} {Typedef 1} {Elaborated 2} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
                Records: [{4 4 struct SA} {4 4 TB}]
                Typedefs: [{2 TA} {4 TB}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 10} {0 42}} 1:{StructDecl 2 0 2 {11 1} {0 7}} 2:{TypedefDecl 3 0 3 {12 1} {9 4}}
            3:{StructDecl 0 0 4 {13 1} {16 6}} 4:{TypedefDecl 4 0 5 {14 1} {15 8}} 5:{VarDecl 5 0 6 {15 1} {25 3}}
            6:{VarDecl 6 0 6 {16 1} {25 5}} 7:{VarDecl 7 0 3 {17 1} {32 2}} 8:{VarDecl 8 0 3 {18 1} {32 4}}
            9:{VarDecl 9 0 5 {19 1} {37 2}} 10:{VarDecl 10 0 5 {20 1} {37 4}} 11:{FieldDecl 11 1 7 {0 0} {3 2}}
            12:{TypeRef 12 2 2 {0 0} {11 1}} 13:{FieldDecl 13 3 7 {0 0} {18 2}} 14:{Back 0 4 0 {0 0} {0 0}}
            15:{TypeRef 12 5 2 {0 0} {26 1}} 16:{Back 0 6 0 {0 0} {0 0}} 17:{TypeRef 3 7 3 {0 0} {32 1}} 18:{Back 0 8 0 {0 0} {0 0}}
            19:{TypeRef 4 9 5 {0 0} {37 1}} 20:{Back 0 10 0 {0 0} {0 0}}
            CursorNameMap:
            0: 1:sample.c 2:SA 3:TA 4:TB 5:x0 6:x1 7:y0 8:y1 9:z0 10:z1 11:a 12:struct SA 13:b
            Back:
            14:3 16:15 18:17 20:19`,
		ExpectedGobSize0: 2383,
		ExpectedGobSize1: 1891,
	},
	{
		Name: "cascade_int_pointers",
		Comment: `
			// What do the simple types and their pointers and arrays look like.
			`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            int a;
            int *b;
            int **c;
            int ***d;
        `,
		ExpectedFullCursors: `
            a/VarDecl {first-seen:1 Int 'int' align:4 size:4}
            b/VarDecl {first-seen:2 Pointer 'int *' *{seen-before:1} align:8 size:8}
            c/VarDecl {first-seen:3 Pointer 'int **' *{seen-before:2} align:8 size:8}
            d/VarDecl {first-seen:4 Pointer 'int ***' *{seen-before:3} align:8 size:8}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:0 4:3 5:4 6:2 7:0 8:3 9:3 10:5 11:2 12:0 13:3 14:3 15:3 16:6 17:2
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Identifier 4} 5:{Identifier 5} 6:{Identifier 6}
            TokenNameMap:
            0:int 1:a 2:; 3:* 4:b 5:c 6:d
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0} {Pointer 2} {Pointer 3} {Pointer 4}]
                Intrinsics: [{{Int} int 4 4}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 4} {0 18}} 1:{VarDecl 2 0 2 {0 0} {0 2}} 2:{VarDecl 3 0 3 {0 0} {3 3}}
            3:{VarDecl 4 0 4 {0 0} {7 4}} 4:{VarDecl 5 0 5 {0 0} {12 5}}
            CursorNameMap:
            0: 1:sample.c 2:a 3:b 4:c 5:d`,
	},
	{
		Name: "cascade_int_arrays",
		Comment: `
			// What do the simple types and their arrays look like.
			// Look at d. Three levels of ContantArray, each with an ElementType, the first two hadn't been seen before. The third one had (it being int).
			// Look at e. The type was seen before for b, even though each had their own int[1] type.
			//   - seen-before kindtype:ContantArray spelling:'int [1]'
			`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            int a;
            int b[1];
            int c[2][3];
            int d[4][5][6];
            int e[1];
        `,
		ExpectedFullCursors: `
            a/VarDecl {first-seen:1 Int 'int' align:4 size:4}
            b/VarDecl {first-seen:2 ConstantArray 'int [1]' align:4 size:4 len:1 elem:{seen-before:1}}
            . 1/IntegerLiteral:IsLiteral/ {seen-before:1}
            c/VarDecl {first-seen:3 ConstantArray 'int [2][3]' align:4 size:24 len:2 elem:{first-seen:4 ConstantArray 'int [3]' align:4 size:12 len:3 elem:{seen-before:1}}}
            . 3/IntegerLiteral:IsLiteral/ {seen-before:1}
            . 2/IntegerLiteral:IsLiteral/ {seen-before:1}
            d/VarDecl {first-seen:5 ConstantArray 'int [4][5][6]' align:4 size:480 len:4 elem:{first-seen:6 ConstantArray 'int [5][6]' align:4 size:120 len:5 elem:{first-seen:7 ConstantArray 'int [6]' align:4 size:24 len:6 elem:{seen-before:1}}}}
            . 6/IntegerLiteral:IsLiteral/ {seen-before:1}
            . 5/IntegerLiteral:IsLiteral/ {seen-before:1}
            . 4/IntegerLiteral:IsLiteral/ {seen-before:1}
            e/VarDecl {seen-before:2}
            . 1/IntegerLiteral:IsLiteral/ {seen-before:1}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:0 4:3 5:4 6:5 7:6 8:2 9:0 10:7 11:4 12:8 13:6 14:4 15:9 16:6 17:2 18:0 19:10 20:4 21:11 22:6 23:4 24:12
            25:6 26:4 27:13 28:6 29:2 30:0 31:14 32:4 33:5 34:6 35:2
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Identifier 3} 4:{Punctuation 4} 5:{Literal 5} 6:{Punctuation 6}
            7:{Identifier 7} 8:{Literal 8} 9:{Literal 9} 10:{Identifier 10} 11:{Literal 11} 12:{Literal 12} 13:{Literal 13}
            14:{Identifier 14}
            TokenNameMap:
            0:int 1:a 2:; 3:b 4:[ 5:1 6:] 7:c 8:2 9:3 10:d 11:4 12:5 13:6 14:e
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0} {ConstantArray 0} {ConstantArray 1} {ConstantArray 2} {ConstantArray 3} {ConstantArray 4} {ConstantArray 5}]
                Intrinsics: [{{Int} int 4 4}]
                Arrays: [{1 {2 4 4 int [1]}} {3 {2 4 12 int [3]}} {2 {4 4 24 int [2][3]}} {6 {2 4 24 int [6]}} {5 {6 4 120 int [5][6]}} {4 {7 4 480 int [4][5][6]}}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 5} {0 36}} 1:{VarDecl 2 0 2 {0 0} {0 2}} 2:{VarDecl 3 0 3 {6 1} {3 5}}
            3:{VarDecl 4 0 5 {7 2} {9 8}} 4:{VarDecl 5 0 8 {9 3} {18 11}} 5:{VarDecl 6 0 3 {12 1} {30 5}}
            6:{IntegerLiteral 0 2 2 {0 0} {6 1}} 7:{IntegerLiteral 0 3 2 {0 0} {15 1}} 8:{IntegerLiteral 0 3 2 {0 0} {12 1}}
            9:{IntegerLiteral 0 4 2 {0 0} {27 1}} 10:{IntegerLiteral 0 4 2 {0 0} {24 1}} 11:{IntegerLiteral 0 4 2 {0 0} {21 1}}
            12:{IntegerLiteral 0 5 2 {0 0} {33 1}}
            CursorNameMap:
            0: 1:sample.c 2:a 3:b 4:c 5:d 6:e`,
	},
	{
		Name: "typekind_VariableArray",
		Comment: `
			// int arr[n] is a VariableArray, as such NumElements() returns -1. No 'len:n' displayed.
			`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            void foo(int n) {
				int arr[n];
			}
        `,
		ExpectedFullCursors: `
            foo/FunctionDecl {first-seen:1 FunctionProto 'void (int)' !POD numargs:1 result:{first-seen:2 Void 'void' !POD} align:4 size:1}
            . n/ParmDecl {first-seen:3 Int 'int' align:4 size:4}
            . CompoundStmt:IsStatement 
            . . DeclStmt:IsStatement 
            . . . arr/VarDecl {first-seen:4 VariableArray 'int [n]' align:4 elem:{seen-before:3}}
            . . . . DeclRefExpr:IsExpression:[n : Identifier]/n {seen-before:3}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:3 8:7 9:8 10:4 11:9 12:10 13:11
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Keyword 3} 4:{Identifier 4} 5:{Punctuation 5} 6:{Punctuation 6}
            7:{Identifier 7} 8:{Punctuation 8} 9:{Punctuation 9} 10:{Punctuation 10} 11:{Punctuation 11}
            TokenNameMap:
            0:void 1:foo 2:( 3:int 4:n 5:) 6:{ 7:arr 8:[ 9:] 10:; 11:}
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0} {Void 1} {FunctionProto 0} {VariableArray 0}]
                Intrinsics: [{{Int} int 4 4} {{Void} void 0 0}]
                Functions: [{{FunctionProto} 3 [2] void (int)}]
                Arrays: [{-1 {2 4 0 int [n]}}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 1} {0 14}} 1:{FunctionDecl 2 0 4 {2 2} {0 14}} 2:{ParmDecl 3 1 2 {0 0} {3 2}}
            3:{CompoundStmt 0 1 0 {4 1} {6 8}} 4:{DeclStmt 0 3 0 {5 1} {7 6}} 5:{VarDecl 4 4 5 {6 1} {7 5}}
            6:{DeclRefExpr 3 5 2 {0 0} {10 1}}
            CursorNameMap:
            0: 1:sample.c 2:foo 3:n 4:arr`,
	},
	{
		Name: "type_enum_anonymous",
		Comment: `
			// 
			`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            enum {
				A,
				B
			}
        `,
		ExpectedFullCursors: `
            /EnumDecl {first-seen:1 Enum 'enum (anonymous at sample.c:2:13)' align:4 size:4}
            . A/EnumConstantDecl {first-seen:2 Int 'int' align:4 size:4}
            . B/EnumConstantDecl {seen-before:2}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5
            TokenMap:
            0:{Keyword 0} 1:{Punctuation 1} 2:{Identifier 2} 3:{Punctuation 3} 4:{Identifier 4} 5:{Punctuation 5}
            TokenNameMap:
            0:enum 1:{ 2:A 3:, 4:B 5:}
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Enum 0} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
                Enums: [{4 4 enum (anonymous at sample.c:2:13)}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 1} {0 6}} 1:{EnumDecl 0 0 2 {2 2} {0 6}} 2:{EnumConstantDecl 2 1 3 {0 0} {2 1}}
            3:{EnumConstantDecl 3 1 3 {0 0} {4 1}}
            CursorNameMap:
            0: 1:sample.c 2:A 3:B`,
	},
	{
		Name: "type_enum_named",
		Comment: `
			// 
			`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            enum MyEnum {
				A,
				B
			}
        `,
		ExpectedFullCursors: `
            MyEnum/EnumDecl {first-seen:1 Enum 'enum MyEnum' align:4 size:4}
            . A/EnumConstantDecl {first-seen:2 Int 'int' align:4 size:4}
            . B/EnumConstantDecl {seen-before:2}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Identifier 3} 4:{Punctuation 4} 5:{Identifier 5} 6:{Punctuation 6}
            TokenNameMap:
            0:enum 1:MyEnum 2:{ 3:A 4:, 5:B 6:}
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Enum 0} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
                Enums: [{4 4 enum MyEnum}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 1} {0 7}} 1:{EnumDecl 2 0 2 {2 2} {0 7}} 2:{EnumConstantDecl 3 1 3 {0 0} {3 1}}
            3:{EnumConstantDecl 4 1 3 {0 0} {5 1}}
            CursorNameMap:
            0: 1:sample.c 2:MyEnum 3:A 4:B`,
	},
	{
		Name: "type_enum_named_with_var",
		Comment: `
			// x is declared without the enum keyword but appears to be handled the same as y.
			`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            enum MyEnum {
				A,
				B
			}
			MyEnum x;
			enum MyEnum y;
        `,
		ExpectedFullCursors: `
            MyEnum/EnumDecl {first-seen:1 Enum 'enum MyEnum' align:4 size:4}
            . A/EnumConstantDecl {first-seen:2 Int 'int' align:4 size:4}
            . B/EnumConstantDecl {seen-before:2}
            x/VarDecl {first-seen:3 Elaborated 'enum MyEnum' Canon:{seen-before:1} align:4 size:4}
            . enum MyEnum/TypeRef {seen-before:1}
            y/VarDecl {seen-before:3}
            . enum MyEnum/TypeRef {seen-before:1}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:1 8:7 9:8 10:0 11:1 12:9 13:8
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Identifier 3} 4:{Punctuation 4} 5:{Identifier 5} 6:{Punctuation 6}
            7:{Identifier 7} 8:{Punctuation 8} 9:{Identifier 9}
            TokenNameMap:
            0:enum 1:MyEnum 2:{ 3:A 4:, 5:B 6:} 7:x 8:; 9:y
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Enum 0} {Elaborated 2} {Int 0}]
                Intrinsics: [{{Int} int 4 4}]
                Enums: [{4 4 enum MyEnum}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 3} {0 14}} 1:{EnumDecl 2 0 2 {4 2} {0 7}} 2:{VarDecl 3 0 3 {6 1} {7 2}}
            3:{VarDecl 4 0 3 {7 1} {10 3}} 4:{EnumConstantDecl 5 1 4 {0 0} {3 1}} 5:{EnumConstantDecl 6 1 4 {0 0} {5 1}}
            6:{TypeRef 7 2 2 {0 0} {7 1}} 7:{TypeRef 7 3 2 {0 0} {11 1}}
            CursorNameMap:
            0: 1:sample.c 2:MyEnum 3:x 4:y 5:A 6:B 7:enum MyEnum`,
	},
	{
		Name:    "const_and_volatile",
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            const int i = 1;
            volatile int j = 1;
        `,
		ExpectedFullCursors: `
            i/VarDecl {first-seen:1 Int 'const int' align:4 size:4 Const}
            . 1/IntegerLiteral:IsLiteral/ {first-seen:2 Int 'int' align:4 size:4}
            j/VarDecl {first-seen:3 Int 'volatile int' align:4 size:4 Volatile}
            . 1/IntegerLiteral:IsLiteral/ {seen-before:2}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:1 8:7 9:3 10:4 11:5
            TokenMap:
            0:{Keyword 0} 1:{Keyword 1} 2:{Identifier 2} 3:{Punctuation 3} 4:{Literal 4} 5:{Punctuation 5} 6:{Keyword 6}
            7:{Identifier 7}
            TokenNameMap:
            0:const 1:int 2:i 3:= 4:1 5:; 6:volatile 7:j
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Int 0} {Int 1} {Int 2}]
                Intrinsics: [{{Int} const int 4 4} {{Int} volatile int 4 4} {{Int} int 4 4}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 2} {0 12}} 1:{VarDecl 2 0 2 {3 1} {0 5}} 2:{VarDecl 3 0 3 {4 1} {6 5}}
            3:{IntegerLiteral 0 1 4 {0 0} {4 1}} 4:{IntegerLiteral 0 2 4 {0 0} {10 1}}
            CursorNameMap:
            0: 1:sample.c 2:i 3:j`,
	},
	{
		Name: "foo_bar_variadic_and_not",
		Comment: `
			// foo is functionNoProto and assumed Variadic.
			// bar is functionProto and not Variadic.
			`,
		SrcCode: `
			void foo() { }
			void bar(void);
			void bar() { }
			`,
		ExpectedFullCursors: `
            foo/FunctionDecl {first-seen:1 FunctionNoProto 'void ()' !POD numargs:0 result:{first-seen:2 Void 'void' !POD} align:4 size:1 Variadic}
            . CompoundStmt:IsStatement 
            bar/FunctionDecl {first-seen:3 FunctionProto 'void (void)' !POD numargs:0 result:{seen-before:2} align:4 size:1}
            bar/FunctionDecl {seen-before:3}
            . CompoundStmt:IsStatement `,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:0 7:6 8:2 9:0 10:3 11:7 12:0 13:6 14:2 15:3 16:4 17:5
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Punctuation 4} 5:{Punctuation 5} 6:{Identifier 6}
            7:{Punctuation 7}
            TokenNameMap:
            0:void 1:foo 2:( 3:) 4:{ 5:} 6:bar 7:;
            TypeMap:
            TypeMap{
                Keys: [{Invalid -1} {Unexposed -1} {Void 0} {FunctionNoProto 0} {FunctionProto 1}]
                Intrinsics: [{{Void} void 0 0}]
                Functions: [{{FunctionNoProto} 2 [] void ()} {{FunctionProto} 2 [] void (void)}]
            }
            Cursors:
            0:{TranslationUnit 1 -1 1 {1 3} {0 18}} 1:{FunctionDecl 2 0 3 {4 1} {0 6}} 2:{FunctionDecl 3 0 4 {0 0} {6 5}}
            3:{FunctionDecl 3 0 4 {5 1} {12 6}} 4:{CompoundStmt 0 1 0 {0 0} {4 2}} 5:{CompoundStmt 0 3 0 {0 0} {16 2}}
            CursorNameMap:
            0: 1:sample.c 2:foo 3:bar`,
	},
}
