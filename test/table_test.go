// Generated by go test -update.
// Edit by hand to add or modify test cases.  Use go test -update to get this
// file regenerated with the expected output of those test cases.
//
// Test cases that you comment out by hand will be lost if the -update flag is
// used.  Rather than comment out the test cases, set their Disable property to
// true if you may want to update the results. The Disable property is
// maintained.
//
// Similarly, any comments you make for yourself while testing will be lost if
// you update this file. But there is a string property named Comment that you
// can use that is retained during update.

package clang_test

import (
	"github.com/frankreh/go-clang-v5.0/clang"
)

var testTupleData = []testTuple{

	{
		Name:             "empty_a1",
		ExpectedGobSize0: 553,
		ExpectedGobSize1: 309,
	},
	{
		Name: "empty_a2",
		ExpectedTUPopulate: `
            Tokens:

            TokenMap:

            TokenNameMap:

            Cursors:
            0:{TranslationUnit 1 -1 {0 0} {0 0}}
            CursorNameMap:
            0: 1:sample.c`,
		ExpectedGobSize0: 553,
		ExpectedGobSize1: 309,
	},
	{
		Name: "void_foo",
		SrcCode: `
			void foo() { }
			`,
		ExpectedTokens: `
            void : Keyword
             foo : Identifier
               ( : Punctuation
               ) : Punctuation
               { : Punctuation
               } : Punctuation`,
		ExpectedTopCursors: `foo FunctionDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            foo/FunctionDecl {FunctionNoProto void ()}
            . CompoundStmt:IsStatement {no type}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Punctuation 4} 5:{Punctuation 5}
            TokenNameMap:
            0:void 1:foo 2:( 3:) 4:{ 5:}
            Cursors:
            0:{TranslationUnit 1 -1 {1 1} {0 6}} 1:{FunctionDecl 2 0 {2 1} {0 6}} 2:{CompoundStmt 0 1 {0 0} {4 2}}
            CursorNameMap:
            0: 1:sample.c 2:foo`,
		ExpectedGobSize0: 642,
		ExpectedGobSize1: 372,
	},
	{
		Name: "charp_foo_if",
		SrcCode: `
			char* foo(int i) { if (i >= 0) return "yes"; else return "no"; }
			`,
		ExpectedTokens: `
              char : Keyword
                 * : Punctuation
               foo : Identifier
                 ( : Punctuation
               int : Keyword
                 i : Identifier
                 ) : Punctuation
                 { : Punctuation
                if : Keyword
                 ( : Punctuation
                 i : Identifier
                >= : Punctuation
                 0 : Literal
                 ) : Punctuation
            return : Keyword
             "yes" : Literal
                 ; : Punctuation
              else : Keyword
            return : Keyword
              "no" : Literal
                 ; : Punctuation
                 } : Punctuation`,
		ExpectedTopCursors: `foo FunctionDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            foo/FunctionDecl {FunctionProto char *(int)}
            . i/ParmDecl {Int int}
            . CompoundStmt:IsStatement {no type}
            . . IfStmt:IsStatement {no type}
            . . . BinaryOperator:IsExpression:[i : Identifier, >= : Punctuation, 0 : Literal]/ {Int int}
            . . . . IsUnexposed(UnexposedExpr) {Int int}
            . . . . . DeclRefExpr:IsExpression:[i : Identifier]/i {Int int}
            . . . . 0/IntegerLiteral:IsLiteral/ {Int int}
            . . . ReturnStmt:IsStatement {no type}
            . . . . IsUnexposed(UnexposedExpr) {Pointer char *}
            . . . . . "yes"/StringLiteral:IsLiteral/"yes" {ConstantArray char [4]}
            . . . ReturnStmt:IsStatement {no type}
            . . . . IsUnexposed(UnexposedExpr) {Pointer char *}
            . . . . . "no"/StringLiteral:IsLiteral/"no" {ConstantArray char [3]}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8 9:3 10:5 11:9 12:10 13:6 14:11 15:12 16:13 17:14 18:11 19:15 20:13 21:16
            TokenMap:
            0:{Keyword 0} 1:{Punctuation 1} 2:{Identifier 2} 3:{Punctuation 3} 4:{Keyword 4} 5:{Identifier 5} 6:{Punctuation 6}
            7:{Punctuation 7} 8:{Keyword 8} 9:{Punctuation 9} 10:{Literal 10} 11:{Keyword 11} 12:{Literal 12} 13:{Punctuation 13}
            14:{Keyword 14} 15:{Literal 15} 16:{Punctuation 16}
            TokenNameMap:
            0:char 1:* 2:foo 3:( 4:int 5:i 6:) 7:{ 8:if 9:>= 10:0 11:return 12:"yes" 13:; 14:else 15:"no" 16:}
            Cursors:
            0:{TranslationUnit 1 -1 {1 1} {0 22}} 1:{FunctionDecl 2 0 {2 2} {0 22}} 2:{ParmDecl 3 1 {0 0} {4 2}}
            3:{CompoundStmt 0 1 {4 1} {7 15}} 4:{IfStmt 0 3 {5 3} {8 12}} 5:{BinaryOperator 6 4 {8 2} {10 3}}
            6:{ReturnStmt 0 4 {10 1} {14 2}} 7:{ReturnStmt 0 4 {11 1} {18 2}} 8:{UnexposedExpr 3 5 {12 1} {10 1}}
            9:{IntegerLiteral 0 5 {0 0} {12 1}} 10:{UnexposedExpr 0 6 {13 1} {15 1}} 11:{UnexposedExpr 0 7 {14 1} {19 1}}
            12:{DeclRefExpr 3 8 {0 0} {10 1}} 13:{StringLiteral 4 10 {0 0} {15 1}} 14:{StringLiteral 5 11 {0 0} {19 1}}
            CursorNameMap:
            0: 1:sample.c 2:foo 3:i 4:"yes" 5:"no" 6:>=`,
		ExpectedGobSize0: 980,
		ExpectedGobSize1: 568,
	},
	{
		Name: "int_foo_if_float",
		SrcCode: `
			int foo(float i) { if (i) return 1; else return 0; }
			`,
		ExpectedFullCursors: `
            foo/FunctionDecl {FunctionProto int (float)}
            . i/ParmDecl {Float float}
            . CompoundStmt:IsStatement {no type}
            . . IfStmt:IsStatement {no type}
            . . . IsUnexposed(UnexposedExpr) {Float float}
            . . . . DeclRefExpr:IsExpression:[i : Identifier]/i {Float float}
            . . . ReturnStmt:IsStatement {no type}
            . . . . 1/IntegerLiteral:IsLiteral/ {Int int}
            . . . ReturnStmt:IsStatement {no type}
            . . . . 0/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedGobSize0: 865,
		ExpectedGobSize1: 503,
	},
	{
		Name:    "int_world",
		SrcCode: `int world();`,
		ExpectedTokens: `
              int : Keyword
            world : Identifier
                ( : Punctuation
                ) : Punctuation
                ; : Punctuation`,
	},
	{
		Name:    "define_A_a_plus_1",
		SrcCode: `#define A(a) (a + 1)`,
		ExpectedTokens: `
                 # : Punctuation
            define : Identifier
                 A : Identifier
                 ( : Punctuation
                 a : Identifier
                 ) : Punctuation
                 ( : Punctuation
                 a : Identifier
                 + : Punctuation
                 1 : Literal
                 ) : Punctuation`,
	},
	{
		Name: "define_A_a_plus_1_called_by_foo",
		SrcCode: `
			#define Add(a) (a + 1)
			int foo(int b) {
				if (b & 0x1) {
					return Add(b);
				}
			}
			`,
		ExpectedTokens: `
                 # : Punctuation
            define : Identifier
               Add : Identifier
                 ( : Punctuation
                 a : Identifier
                 ) : Punctuation
                 ( : Punctuation
                 a : Identifier
                 + : Punctuation
                 1 : Literal
                 ) : Punctuation
               int : Keyword
               foo : Identifier
                 ( : Punctuation
               int : Keyword
                 b : Identifier
                 ) : Punctuation
                 { : Punctuation
                if : Keyword
                 ( : Punctuation
                 b : Identifier
                 & : Punctuation
               0x1 : Literal
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
               Add : Identifier
                 ( : Punctuation
                 b : Identifier
                 ) : Punctuation
                 ; : Punctuation
                 } : Punctuation
                 } : Punctuation`,
	},
	{
		Name: "static_var_and_func",
		SrcCode: `
			static int sa = 7;
			static int getsaI() {
				return sa
			}
			int getsa() {
				return getsaI()
			}
			`,
		ExpectedTokens: `
            static : Keyword
               int : Keyword
                sa : Identifier
                 = : Punctuation
                 7 : Literal
                 ; : Punctuation
            static : Keyword
               int : Keyword
            getsaI : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
                sa : Identifier
                 } : Punctuation
               int : Keyword
             getsa : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
            getsaI : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 } : Punctuation`,
	},
	{
		Name:    "global_var_int_a_is_1",
		SrcCode: `int a = 1;`,
		ExpectedTokens: `
            int : Keyword
              a : Identifier
              = : Punctuation
              1 : Literal
              ; : Punctuation`,
		ExpectedTopCursors: `a VarDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            a/VarDecl {Int int}
            . 1/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Literal 3} 4:{Punctuation 4}
            TokenNameMap:
            0:int 1:a 2:= 3:1 4:;
            Cursors:
            0:{TranslationUnit 1 -1 {1 1} {0 5}} 1:{VarDecl 2 0 {2 1} {0 4}} 2:{IntegerLiteral 0 1 {0 0} {3 1}}
            CursorNameMap:
            0: 1:sample.c 2:a`,
		ExpectedGobSize0: 632,
		ExpectedGobSize1: 362,
	},
	{
		Name:    "global_var_unsigned_int_a_is_0x1",
		SrcCode: `unsigned int a = 0x1;`,
		ExpectedTokens: `
            unsigned : Keyword
                 int : Keyword
                   a : Identifier
                   = : Punctuation
                 0x1 : Literal
                   ; : Punctuation`,
		ExpectedTopCursors: `a VarDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            a/VarDecl {UInt unsigned int}
            . IsUnexposed(UnexposedExpr) {UInt unsigned int}
            . . 0x1/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedGobSize0: 668,
		ExpectedGobSize1: 385,
	},
	{
		Name:    "global_var_a_is_0_001",
		SrcCode: `double a = 0.001;`,
		ExpectedTokens: `
            double : Keyword
                 a : Identifier
                 = : Punctuation
             0.001 : Literal
                 ; : Punctuation`,
		ExpectedTopCursors: `a VarDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            a/VarDecl {Double double}
            . 0.001/FloatingLiteral:IsLiteral/ {Double double}`,
		ExpectedGobSize0: 639,
		ExpectedGobSize1: 369,
	},
	{
		Name: "function_storage_comparison",
		SrcCode: `int A() { return 1; }
			  extern int B() {return 2; }
			  static int C() {return 3; }
			  inline int D() {return 4; }
			  `,
		ExpectedTopCursors: `
            A FunctionDecl IsDeclaration SC_None   Linkage_External
            B FunctionDecl IsDeclaration SC_Extern Linkage_External
            C FunctionDecl IsDeclaration SC_Static Linkage_Internal
            D FunctionDecl IsDeclaration SC_None   Linkage_External`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8 9:9 10:0 11:10 12:2 13:3 14:4 15:5 16:11 17:7 18:8 19:12 20:0 21:13 22:2 23:3 24:4
            25:5 26:14 27:7 28:8 29:15 30:0 31:16 32:2 33:3 34:4 35:5 36:17 37:7 38:8
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Punctuation 4} 5:{Keyword 5} 6:{Literal 6}
            7:{Punctuation 7} 8:{Punctuation 8} 9:{Keyword 9} 10:{Identifier 10} 11:{Literal 11} 12:{Keyword 12} 13:{Identifier 13}
            14:{Literal 14} 15:{Keyword 15} 16:{Identifier 16} 17:{Literal 17}
            TokenNameMap:
            0:int 1:A 2:( 3:) 4:{ 5:return 6:1 7:; 8:} 9:extern 10:B 11:2 12:static 13:C 14:3 15:inline 16:D 17:4
            Cursors:
            0:{TranslationUnit 1 -1 {1 4} {0 39}} 1:{FunctionDecl 2 0 {5 1} {0 9}} 2:{FunctionDecl 3 0 {6 1} {9 10}}
            3:{FunctionDecl 4 0 {7 1} {19 10}} 4:{FunctionDecl 5 0 {8 1} {29 10}} 5:{CompoundStmt 0 1 {9 1} {4 5}}
            6:{CompoundStmt 0 2 {10 1} {14 5}} 7:{CompoundStmt 0 3 {11 1} {24 5}} 8:{CompoundStmt 0 4 {12 1} {34 5}}
            9:{ReturnStmt 0 5 {13 1} {5 2}} 10:{ReturnStmt 0 6 {14 1} {15 2}} 11:{ReturnStmt 0 7 {15 1} {25 2}}
            12:{ReturnStmt 0 8 {16 1} {35 2}} 13:{IntegerLiteral 0 9 {0 0} {6 1}} 14:{IntegerLiteral 0 10 {0 0} {16 1}}
            15:{IntegerLiteral 0 11 {0 0} {26 1}} 16:{IntegerLiteral 0 12 {0 0} {36 1}}
            CursorNameMap:
            0: 1:sample.c 2:A 3:B 4:C 5:D`,
		ExpectedGobSize0: 1024,
		ExpectedGobSize1: 596,
	},
	{
		Name:    "void_function_and_return",
		SrcCode: `void A() { return; }`,
		ExpectedTokens: `
              void : Keyword
                 A : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
                 ; : Punctuation
                 } : Punctuation`,
		ExpectedTopCursors: `A FunctionDecl IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            A/FunctionDecl {FunctionNoProto void ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}`,
		ExpectedGobSize0: 677,
		ExpectedGobSize1: 394,
	},
	{
		Name:    "int_function_and_return_1",
		SrcCode: `int A() { return 1; }`,
		ExpectedFullCursors: `
            A/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . 1/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedGobSize0: 702,
		ExpectedGobSize1: 407,
	},
	{
		Name: "parenthesis_comparison",
		SrcCode: `int A() { return 1; }
					  int B() { return (2); }
					  int C() { return ((2)); }
					  `,
		ExpectedFullCursors: `
            A/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . 1/IntegerLiteral:IsLiteral/ {Int int}
            B/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . ParenExpr:IsExpression:[( : Punctuation, 2 : Literal, ) : Punctuation]/ {Int int}
            . . . . 2/IntegerLiteral:IsLiteral/ {Int int}
            C/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . ParenExpr:IsExpression:[( : Punctuation, ( : Punctuation, 2 : Literal, ) : Punctuation, ) : Punctuation]/ {Int int}
            . . . . ParenExpr:IsExpression:[( : Punctuation, 2 : Literal, ) : Punctuation]/ {Int int}
            . . . . . 2/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedGobSize0: 944,
		ExpectedGobSize1: 524,
	},
	{
		Name: "func_sub_77_and_78",
		SrcCode: `int A() { return 77 - 78; }
					  `,
		ExpectedTokens: `
               int : Keyword
                 A : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
                77 : Literal
                 - : Punctuation
                78 : Literal
                 ; : Punctuation
                 } : Punctuation`,
		ExpectedFullCursors: `
            A/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . BinaryOperator:IsExpression:[77 : Literal, - : Punctuation, 78 : Literal]/ {Int int}
            . . . . 77/IntegerLiteral:IsLiteral/ {Int int}
            . . . . 78/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8 9:9 10:10
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Punctuation 4} 5:{Keyword 5} 6:{Literal 6}
            7:{Punctuation 7} 8:{Literal 8} 9:{Punctuation 9} 10:{Punctuation 10}
            TokenNameMap:
            0:int 1:A 2:( 3:) 4:{ 5:return 6:77 7:- 8:78 9:; 10:}
            Cursors:
            0:{TranslationUnit 1 -1 {1 1} {0 11}} 1:{FunctionDecl 2 0 {2 1} {0 11}} 2:{CompoundStmt 0 1 {3 1} {4 7}}
            3:{ReturnStmt 0 2 {4 1} {5 4}} 4:{BinaryOperator 3 3 {5 2} {6 3}} 5:{IntegerLiteral 0 4 {0 0} {6 1}}
            6:{IntegerLiteral 0 4 {0 0} {8 1}}
            CursorNameMap:
            0: 1:sample.c 2:A 3:-`,
		ExpectedGobSize0: 754,
		ExpectedGobSize1: 437,
	},
	{
		Name:    "var_sub_77_and_78",
		SrcCode: `int a = 77 - 78;`,
		ExpectedTokens: `
            int : Keyword
              a : Identifier
              = : Punctuation
             77 : Literal
              - : Punctuation
             78 : Literal
              ; : Punctuation`,
		ExpectedFullCursors: `
            a/VarDecl {Int int}
            . BinaryOperator:IsExpression:[77 : Literal, - : Punctuation, 78 : Literal]/ {Int int}
            . . 77/IntegerLiteral:IsLiteral/ {Int int}
            . . 78/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Literal 3} 4:{Punctuation 4} 5:{Literal 5} 6:{Punctuation 6}
            TokenNameMap:
            0:int 1:a 2:= 3:77 4:- 5:78 6:;
            Cursors:
            0:{TranslationUnit 1 -1 {1 1} {0 7}} 1:{VarDecl 2 0 {2 1} {0 6}} 2:{BinaryOperator 3 1 {3 2} {3 3}}
            3:{IntegerLiteral 0 2 {0 0} {3 1}} 4:{IntegerLiteral 0 2 {0 0} {5 1}}
            CursorNameMap:
            0: 1:sample.c 2:a 3:-`,
		ExpectedGobSize0: 685,
		ExpectedGobSize1: 392,
	},
	{
		Name:    "var_sub_p77p_and_78",
		Comment: `BinaryOperator - has 5 tokens and 2 children. First child has 3 tokens. Means the 4th is the binary operator symbol.`,
		SrcCode: `int a = (77) - 78;`,
		ExpectedTokens: `
            int : Keyword
              a : Identifier
              = : Punctuation
              ( : Punctuation
             77 : Literal
              ) : Punctuation
              - : Punctuation
             78 : Literal
              ; : Punctuation`,
		ExpectedFullCursors: `
            a/VarDecl {Int int}
            . BinaryOperator:IsExpression:[( : Punctuation, 77 : Literal, ) : Punctuation, - : Punctuation, 78 : Literal]/ {Int int}
            . . ParenExpr:IsExpression:[( : Punctuation, 77 : Literal, ) : Punctuation]/ {Int int}
            . . . 77/IntegerLiteral:IsLiteral/ {Int int}
            . . 78/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Literal 4} 5:{Punctuation 5} 6:{Punctuation 6}
            7:{Literal 7} 8:{Punctuation 8}
            TokenNameMap:
            0:int 1:a 2:= 3:( 4:77 5:) 6:- 7:78 8:;
            Cursors:
            0:{TranslationUnit 1 -1 {1 1} {0 9}} 1:{VarDecl 2 0 {2 1} {0 8}} 2:{BinaryOperator 3 1 {3 2} {3 5}}
            3:{ParenExpr 0 2 {5 1} {3 3}} 4:{IntegerLiteral 0 2 {0 0} {7 1}} 5:{IntegerLiteral 0 3 {0 0} {4 1}}
            CursorNameMap:
            0: 1:sample.c 2:a 3:-`,
		ExpectedGobSize0: 715,
		ExpectedGobSize1: 410,
	},
	{
		Name:    "var_a_is_minus_b",
		Comment: ` UnaryOperator - has 2 tokens and 1 children. First child has 1 token. Means the 1st is the unary operator symbol.`,
		SrcCode: `int a = 99;
					  int b = -a;`,
		ExpectedTokens: `
            int : Keyword
              a : Identifier
              = : Punctuation
             99 : Literal
              ; : Punctuation
            int : Keyword
              b : Identifier
              = : Punctuation
              - : Punctuation
              a : Identifier
              ; : Punctuation`,
		ExpectedFullCursors: `
            a/VarDecl {Int int}
            . 99/IntegerLiteral:IsLiteral/ {Int int}
            b/VarDecl {Int int}
            . UnaryOperator:IsExpression:[- : Punctuation, a : Identifier]/ {Int int}
            . . IsUnexposed(UnexposedExpr) {Int int}
            . . . DeclRefExpr:IsExpression:[a : Identifier]/a {Int int}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:0 6:5 7:2 8:6 9:1 10:4
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Literal 3} 4:{Punctuation 4} 5:{Identifier 5} 6:{Punctuation 6}
            TokenNameMap:
            0:int 1:a 2:= 3:99 4:; 5:b 6:-
            Cursors:
            0:{TranslationUnit 1 -1 {1 2} {0 11}} 1:{VarDecl 2 0 {3 1} {0 4}} 2:{VarDecl 3 0 {4 1} {5 5}}
            3:{IntegerLiteral 0 1 {0 0} {3 1}} 4:{UnaryOperator 0 2 {5 1} {8 2}} 5:{UnexposedExpr 2 4 {6 1} {9 1}}
            6:{DeclRefExpr 2 5 {0 0} {9 1}}
            CursorNameMap:
            0: 1:sample.c 2:a 3:b`,
		ExpectedGobSize0: 725,
		ExpectedGobSize1: 406,
	},
	{
		Name: "add_sub_mul_div",
		SrcCode: `int A() { return 1 + 2 - 3 * 4 / 5; }
					  `,
		ExpectedTokens: `
               int : Keyword
                 A : Identifier
                 ( : Punctuation
                 ) : Punctuation
                 { : Punctuation
            return : Keyword
                 1 : Literal
                 + : Punctuation
                 2 : Literal
                 - : Punctuation
                 3 : Literal
                 * : Punctuation
                 4 : Literal
                 / : Punctuation
                 5 : Literal
                 ; : Punctuation
                 } : Punctuation`,
		ExpectedFullCursors: `
            A/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . BinaryOperator:IsExpression:[1 : Literal, + : Punctuation, 2 : Literal, - : Punctuation, 3 : Literal, * : Punctuation, 4 : Literal, / : Punctuation, 5 : Literal]/ {Int int}
            . . . . BinaryOperator:IsExpression:[1 : Literal, + : Punctuation, 2 : Literal]/ {Int int}
            . . . . . 1/IntegerLiteral:IsLiteral/ {Int int}
            . . . . . 2/IntegerLiteral:IsLiteral/ {Int int}
            . . . . BinaryOperator:IsExpression:[3 : Literal, * : Punctuation, 4 : Literal, / : Punctuation, 5 : Literal]/ {Int int}
            . . . . . BinaryOperator:IsExpression:[3 : Literal, * : Punctuation, 4 : Literal]/ {Int int}
            . . . . . . 3/IntegerLiteral:IsLiteral/ {Int int}
            . . . . . . 4/IntegerLiteral:IsLiteral/ {Int int}
            . . . . . 5/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8 9:9 10:10 11:11 12:12 13:13 14:14 15:15 16:16
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Punctuation 3} 4:{Punctuation 4} 5:{Keyword 5} 6:{Literal 6}
            7:{Punctuation 7} 8:{Literal 8} 9:{Punctuation 9} 10:{Literal 10} 11:{Punctuation 11} 12:{Literal 12}
            13:{Punctuation 13} 14:{Literal 14} 15:{Punctuation 15} 16:{Punctuation 16}
            TokenNameMap:
            0:int 1:A 2:( 3:) 4:{ 5:return 6:1 7:+ 8:2 9:- 10:3 11:* 12:4 13:/ 14:5 15:; 16:}
            Cursors:
            0:{TranslationUnit 1 -1 {1 1} {0 17}} 1:{FunctionDecl 2 0 {2 1} {0 17}} 2:{CompoundStmt 0 1 {3 1} {4 13}}
            3:{ReturnStmt 0 2 {4 1} {5 10}} 4:{BinaryOperator 3 3 {5 2} {6 9}} 5:{BinaryOperator 4 4 {7 2} {6 3}}
            6:{BinaryOperator 5 4 {9 2} {10 5}} 7:{IntegerLiteral 0 5 {0 0} {6 1}} 8:{IntegerLiteral 0 5 {0 0} {8 1}}
            9:{BinaryOperator 6 6 {11 2} {10 3}} 10:{IntegerLiteral 0 6 {0 0} {14 1}} 11:{IntegerLiteral 0 9 {0 0} {10 1}}
            12:{IntegerLiteral 0 9 {0 0} {12 1}}
            CursorNameMap:
            0: 1:sample.c 2:A 3:- 4:+ 5:/ 6:*`,
		ExpectedGobSize0: 903,
		ExpectedGobSize1: 519,
	},
	{
		Name: "add_and_double_add",
		SrcCode: `int A() { return 1 + 2; }
					  int B() { return 1 + 2 + 3; }
					  `,
		ExpectedFullCursors: `
            A/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . BinaryOperator:IsExpression:[1 : Literal, + : Punctuation, 2 : Literal]/ {Int int}
            . . . . 1/IntegerLiteral:IsLiteral/ {Int int}
            . . . . 2/IntegerLiteral:IsLiteral/ {Int int}
            B/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . BinaryOperator:IsExpression:[1 : Literal, + : Punctuation, 2 : Literal, + : Punctuation, 3 : Literal]/ {Int int}
            . . . . BinaryOperator:IsExpression:[1 : Literal, + : Punctuation, 2 : Literal]/ {Int int}
            . . . . . 1/IntegerLiteral:IsLiteral/ {Int int}
            . . . . . 2/IntegerLiteral:IsLiteral/ {Int int}
            . . . . 3/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedGobSize0: 919,
		ExpectedGobSize1: 513,
	},
	{
		Name:    "hdr_processing_only",
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		HdrCode: `
			  extern int hdr_ext_v;
			  static int hdr_sta_v;
			  static int hdr_sta_v = 2;
			  int hdr_glo_v = 3;

			  extern int hdr_ext_f();
			  inline int hdr_inl_f()       { return 11; }
			  static int hdr_sta_f()       { return 12; }
			  int hdr_glo_f()	           { return 13; }
			  static inline int hdr_si_f() { return 14; }
			  `,
		ExpectedGobSize0: 616,
		ExpectedGobSize1: 358,
	},
	{
		Name:    "hdr_and_source",
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		HdrCode: `#define MSG "Hello World!"
			  extern int printf(const char* fmt);
			  `,
		SrcCode: `int A() { return 1; }
			  extern int B() {return 2; }
			  static int C() {return 3; }
			  inline int D() {return 4; }
			  `,
		ExpectedTopCursors: `
            A FunctionDecl IsDeclaration SC_None   Linkage_External
            B FunctionDecl IsDeclaration SC_Extern Linkage_External
            C FunctionDecl IsDeclaration SC_Static Linkage_Internal
            D FunctionDecl IsDeclaration SC_None   Linkage_External`,
		ExpectedFullCursors: `
            A/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . 1/IntegerLiteral:IsLiteral/ {Int int}
            B/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . 2/IntegerLiteral:IsLiteral/ {Int int}
            C/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . 3/IntegerLiteral:IsLiteral/ {Int int}
            D/FunctionDecl {FunctionNoProto int ()}
            . CompoundStmt:IsStatement {no type}
            . . ReturnStmt:IsStatement {no type}
            . . . 4/IntegerLiteral:IsLiteral/ {Int int}`,
		ExpectedGobSize0: 1079,
		ExpectedGobSize1: 643,
	},
	{
		Name:    "struct_a_b",
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
				  struct StructS {
					  int a;
					  char b;
				  } VarS;
				  `,
		ExpectedTokens: `
             struct : Keyword
            StructS : Identifier
                  { : Punctuation
                int : Keyword
                  a : Identifier
                  ; : Punctuation
               char : Keyword
                  b : Identifier
                  ; : Punctuation
                  } : Punctuation
               VarS : Identifier
                  ; : Punctuation`,
		ExpectedTopCursors: `
            StructS StructDecl IsDeclaration         Linkage_External
            VarS    VarDecl    IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            StructS/StructDecl {Record struct StructS}
            . a/FieldDecl {Int int}
            . b/FieldDecl {Char_S char}
            VarS/VarDecl {Elaborated(Record) struct StructS}
            . [0 backreference]`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:5 9:8 10:9 11:5
            TokenMap:
            0:{Keyword 0} 1:{Identifier 1} 2:{Punctuation 2} 3:{Keyword 3} 4:{Identifier 4} 5:{Punctuation 5} 6:{Keyword 6}
            7:{Identifier 7} 8:{Punctuation 8} 9:{Identifier 9}
            TokenNameMap:
            0:struct 1:StructS 2:{ 3:int 4:a 5:; 6:char 7:b 8:} 9:VarS
            Cursors:
            0:{TranslationUnit 1 -1 {1 2} {0 12}} 1:{StructDecl 2 0 {3 2} {0 10}} 2:{VarDecl 3 0 {5 1} {0 11}}
            3:{FieldDecl 4 1 {0 0} {3 2}} 4:{FieldDecl 5 1 {0 0} {6 2}} 5:{Back 0 2 {0 0} {0 0}}
            CursorNameMap:
            0: 1:sample.c 2:StructS 3:VarS 4:a 5:b
            Back:
            5:1`,
		ExpectedGobSize0: 747,
		ExpectedGobSize1: 450,
	},
	{
		Name:    "typedef_int_II",
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
				  typedef int II;
				  II ii;
				  `,
		ExpectedTokens: `
            typedef : Keyword
                int : Keyword
                 II : Identifier
                  ; : Punctuation
                 II : Identifier
                 ii : Identifier
                  ; : Punctuation`,
		ExpectedTopCursors: `
            II TypedefDecl IsDeclaration         Linkage_NoLinkage
            ii VarDecl     IsDeclaration SC_None Linkage_External `,
		ExpectedFullCursors: `
            II/TypedefDecl {Typedef(Int) II}
            ii/VarDecl {Typedef(Int) II}
            . II/TypeRef {Typedef(Int) II}`,
		ExpectedGobSize0: 663,
		ExpectedGobSize1: 382,
	},
	{
		Name:    "typedef_struct_SS",
		Comment: `The 4th cursor encountered is the same as the first.`,
		Options: clang.TranslationUnit_DetailedPreprocessingRecord,
		SrcCode: `
            typedef struct { int a; } SS;
            SS ss;
        `,
		ExpectedTopCursors: `
               StructDecl  IsDeclaration         Linkage_External
            SS TypedefDecl IsDeclaration         Linkage_External
            ss VarDecl     IsDeclaration SC_None Linkage_External`,
		ExpectedFullCursors: `
            /StructDecl {Record SS}
            . a/FieldDecl {Int int}
            SS/TypedefDecl {Typedef(Record) SS}
            . [0 backreference]
            ss/VarDecl {Typedef(Record) SS}
            . SS/TypeRef {Typedef(Record) SS}`,
		ExpectedTUPopulate: `
            Tokens:
            0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:5 9:7 10:8 11:5
            TokenMap:
            0:{Keyword 0} 1:{Keyword 1} 2:{Punctuation 2} 3:{Keyword 3} 4:{Identifier 4} 5:{Punctuation 5} 6:{Punctuation 6}
            7:{Identifier 7} 8:{Identifier 8}
            TokenNameMap:
            0:typedef 1:struct 2:{ 3:int 4:a 5:; 6:} 7:SS 8:ss
            Cursors:
            0:{TranslationUnit 1 -1 {1 3} {0 12}} 1:{StructDecl 0 0 {4 1} {1 6}} 2:{TypedefDecl 2 0 {5 1} {0 8}}
            3:{VarDecl 3 0 {6 1} {9 2}} 4:{FieldDecl 4 1 {0 0} {3 2}} 5:{Back 0 2 {0 0} {0 0}} 6:{TypeRef 2 3 {0 0} {9 1}}
            CursorNameMap:
            0: 1:sample.c 2:SS 3:ss 4:a
            Back:
            5:1`,
		ExpectedGobSize0: 744,
		ExpectedGobSize1: 435,
	},
}
